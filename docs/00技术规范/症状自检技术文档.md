# 症状自检助手模块技术文档

## 一、功能概述
```text
实现症状关键词匹配疾病功能，支持：
1. 登录用户保存检测记录
2. 疾病列表展示与详情跳转
3. 权限控制与安全校验
```

## 二、数据库变更
```sql
-- 新增症状记录表
CREATE TABLE `symptom_log` (
  `id` int NOT NULL AUTO_INCREMENT,
  `user_id` int DEFAULT NULL COMMENT \'用户ID\',
  `keyword` varchar(255) NOT NULL COMMENT \'症状关键词\',
  `first_illness` varchar(100) DEFAULT NULL COMMENT \'首个匹配疾病\',
  `illness_ids` varchar(255) DEFAULT NULL COMMENT \'疾病ID列表\',
  `create_time` datetime DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  KEY `idx_user` (`user_id`),
  CONSTRAINT `fk_user` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`) ON DELETE SET NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- 添加全文索引
ALTER TABLE illness 
ADD FULLTEXT INDEX idx_symptom (illness_symptom);
```

## 三、接口设计
### 1. 症状搜索接口
```java
@ApiOperation("症状匹配查询")
@GetMapping("/search")
public RespResult<List<Illness>> searchSymptoms(
    @RequestParam String keyword,
    @RequestParam(defaultValue = "5") Integer limit) {
    
    // 清洗关键词（去除首尾空格/多个空格合并）
    String cleanKeyword = keyword.trim().replaceAll("\\\\s+", " ");
    
    List<Illness> data = illnessService.searchBySymptoms(cleanKeyword, limit);
    return RespResult.success(data);
}
```

### 2. 症状保存接口
```java
@ApiOperation("保存症状记录")
@PostMapping("/save")
public RespResult<SymptomLog> saveSymptom(
    @RequestParam String keyword,
    @RequestParam String illnessIds) {
    
    // 登录校验
    if (loginUser == null) {
        return RespResult.fail(401, "请先登录");
    }
    
    // 构建存储对象
    SymptomLog log = new SymptomLog()
        .setUserId(loginUser.getId())
        .setKeyword(keyword)
        .setIllnessIds(illnessIds);
    
    // 设置首个疾病名称
    if (StringUtils.hasText(illnessIds)) {
        Integer firstId = Integer.parseInt(illnessIds.split(",")[0]);
        log.setFirstIllness(illnessService.get(firstId).getIllnessName());
    }
    
    return super.save(log);
}
```

## 四、安全策略
```javascript
// 前端请求示例（带频率控制）
function searchSymptoms() {
    let timer;
    return function(keyword) {
        clearTimeout(timer);
        timer = setTimeout(() => {
            fetch(`/symptom/search?keyword=${encodeURIComponent(keyword)}`)
                .then(handleResponse)
                .catch(showError);
        }, 500); // 500ms防抖
    }
}

// 权限校验拦截器
public class AuthInterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request, 
                            HttpServletResponse response, 
                            Object handler) {
        String uri = request.getRequestURI();
        if (uri.startsWith("/symptom/save") && !isLogin()) {
            response.sendError(401);
            return false;
        }
        return true;
    }
}
```

## 五、前端实现要点
```html
<!-- 症状列表页片段 -->
<tr th:each="log : ${logs}">
    <td th:text="${log.id}"></td>
    <td th:text="${log.keyword}"></td>
    <td>
        <span th:text="${log.firstIllness} ?: \'无匹配疾病\'"></span>
        <span th:if="${#lists.size(log.illnessIds.split(\',\')) > 1}">...</span>
    </td>
    <td>
        <a th:href="@{/symptom/detail/{id}(id=${log.id})" 
           class="btn btn-sm btn-info">
            <i class="fa fa-eye"></i>
        </a>
        <button class="btn btn-sm btn-danger" 
                th:if="${loginUser != null}"
                onclick="deleteLog(${log.id})">
            <i class="fa fa-trash"></i>
        </button>
    </td>
</tr>
```

## 六、测试用例
```gherkin
Feature: 症状自检功能测试

  Scenario: 游客基础搜索
    Given 用户未登录
    When 访问"/symptom/search?keyword=头痛"
    Then 返回状态码200
     And 响应包含相关疾病数据

  Scenario: 用户保存记录
    Given 用户已登录
    When POST "/symptom/save" 参数 keyword="头痛" illnessIds="2,5"
    Then 返回状态码200
     And 数据库存在对应记录

  Scenario: 越权删除
    Given 用户A登录
    When 删除用户B的记录
    Then 返回状态码403
```